<!--
 * @LastEditors: å°‰æ—­èƒœ(Riansin)
 * @Author: å°‰æ—­èƒœ(Riansin)
-->
# å­¦ä¹ ç®—æ³•--æˆ‘çš„leetcodeé¢˜è§£

## 1.å“ˆå¸Œè¡¨

###  å“ˆå¸Œé›†åˆ

ä½¿ç”¨æ¡¶ï¼Œä½¿ç”¨å“ˆå¸Œå‡½æ•°è·å–åˆ°è¯¥å€¼å¯¹åº”æ¡¶ğŸª£çš„ä¸‹æ ‡ï¼Œ`add`æ–¹æ³•çš„å®ç°ï¼šåˆ¤æ–­åœ¨æ¡¶ä¸­æœ‰æ— è¯¥å€¼ï¼Œæœ‰å°±è·³è¿‡ï¼Œæ²¡æœ‰å°±pushè¿›å»ã€‚

```ts
class MyHashSet {
    constructor() {
        this.CAPACITY=997;
        this.bucket = new Array(this.CAPACITY).fill(0).map(()=>new Array());
    }
    hash(input:number):number{
        return input % this.CAPACITY;
    }
    bucket:Array<Array<number>>
    CAPACITY:number
    add(key: number): void {
        const value = this.hash(key);
        this.bucket[value].indexOf(key) !== -1 ? void 0 : this.bucket[value].push(key);
    }

    remove(key: number): void {
        const value = this.hash(key);
        const index = this.bucket[value].indexOf(key);
        index === -1 ? void 0 : this.bucket[value].splice(index,1);
    }
    contains(key: number): boolean {
        const value = this.hash(key);
        return this.bucket[value].indexOf(key) === -1 ? false : true;
    }
}

/**
 * Your MyHashSet object will be instantiated and called as such:
 * var obj = new MyHashSet()
 * obj.add(key)
 * obj.remove(key)
 * var param_3 = obj.contains(key)
 */
```



###  å“ˆå¸Œæ˜ å°„

```ts
class MyHashMap {
    //æ¡¶
    bucket:Array<Array<Array<number>>>
  	//æ¡¶çš„æœ€å¤§å®¹é‡
    CAPACITY:number = 997
    constructor(){
        //åˆå§‹åŒ–æ¡¶
        this.bucket = new Array(this.CAPACITY).fill(0).map(()=>new Array())
    }
  	//å“ˆå¸Œå‡½æ•°
    hash(input:number):number{
        return input % this.CAPACITY;
    }
  	//å¾—åˆ°æ¡¶çš„ä¸‹æ ‡
    getindex(key:number){
        return this.hash(key);
    }
    
    getpos(key:number,hash: number,reduce?:Function){
        for(let item of this.bucket[hash]){
            if(item && item[0] === key){
                if(reduce){
                    return reduce(item,this.bucket[hash])
                }
                return item[1]
            }
        }
        return false
    }
    
    put(key: number, value: number): void {
        const hash = this.getindex(key);
        const index = this.getpos(key,hash,function(item,data){
            return data.indexOf(item);
        })
        index !== false ? this.bucket[hash][index][1] = value : this.bucket[hash].push([key,value]);
    }

    get(key: number): number {
        const hash = this.getindex(key);
        const pos =this.getpos(key,hash);
        return pos !== false ? pos : -1;
    }

    remove(key: number): void {
        const hash = this.getindex(key);
        const index = this.getpos(key,hash,function(item,data){
            return data.indexOf(item);
        })
        index === -1 ? null : this.bucket[hash][index] = undefined;
      	//deleteæœ‰æ€§èƒ½é—®é¢˜
        //index === -1 ? null : delete this.bucket[hash][index];
    }
}

/**
 * Your MyHashMap object will be instantiated and called as such:
 * var obj = new MyHashMap()
 * obj.put(key,value)
 * var param_2 = obj.get(key)
 * obj.remove(key)
 */
```

```ts
class MyHashMap {
  map: Map<number, number>;
  constructor() {
    this.map = new Map();
  }

  put(key: number, value: number): void {
    this.map.set(key, value);
  }

  get(key: number): number {
    return this.map.get(key) ?? -1;
  }

  remove(key: number): void {
    this.map.delete(key);
  }
}
```

å®ä¾‹ï¼š

####  æ•°ç»„çš„äº¤é›†

**ä¸¤ä¸ªæ•°ç»„çš„äº¤é›† II**

*ç»™ä½ ä¸¤ä¸ªæ•´æ•°æ•°ç»„ nums1 å’Œ nums2 ï¼Œè¯·ä½ ä»¥æ•°ç»„å½¢å¼è¿”å›ä¸¤æ•°ç»„çš„äº¤é›†ã€‚è¿”å›ç»“æœä¸­æ¯ä¸ªå…ƒç´ å‡ºç°çš„æ¬¡æ•°ï¼Œåº”ä¸å…ƒç´ åœ¨ä¸¤ä¸ªæ•°ç»„ä¸­éƒ½å‡ºç°çš„æ¬¡æ•°ä¸€è‡´ï¼ˆå¦‚æœå‡ºç°æ¬¡æ•°ä¸ä¸€è‡´ï¼Œåˆ™è€ƒè™‘å–è¾ƒå°å€¼ï¼‰ã€‚å¯ä»¥ä¸è€ƒè™‘è¾“å‡ºç»“æœçš„é¡ºåºã€‚*



ç¤ºä¾‹ 1ï¼š

> è¾“å…¥ï¼šnums1 = [1,2,2,1], nums2 = [2,2]
> è¾“å‡ºï¼š[2,2]

ç¤ºä¾‹ 2:

> è¾“å…¥ï¼šnums1 = [4,9,5], nums2 = [9,4,9,8,4]
> è¾“å‡ºï¼š[4,9]


æç¤ºï¼š

> 1 <= nums1.length, nums2.length <= 1000
> 0 <= nums1[i], nums2[i] <= 1000


è¿›é˜¶ï¼š

å¦‚æœç»™å®šçš„æ•°ç»„å·²ç»æ’å¥½åºå‘¢ï¼Ÿä½ å°†å¦‚ä½•ä¼˜åŒ–ä½ çš„ç®—æ³•ï¼Ÿ
å¦‚æœ nums1 çš„å¤§å°æ¯” nums2 å°ï¼Œå“ªç§æ–¹æ³•æ›´ä¼˜ï¼Ÿ
å¦‚æœ nums2 çš„å…ƒç´ å­˜å‚¨åœ¨ç£ç›˜ä¸Šï¼Œå†…å­˜æ˜¯æœ‰é™çš„ï¼Œå¹¶ä¸”ä½ ä¸èƒ½ä¸€æ¬¡åŠ è½½æ‰€æœ‰çš„å…ƒç´ åˆ°å†…å­˜ä¸­ï¼Œä½ è¯¥æ€ä¹ˆåŠï¼Ÿ

è§£æ³•ï¼š

####  åˆ©ç”¨æ’åºå’ŒåŒæŒ‡é’ˆ

```ts
function intersect(nums1: number[], nums2: number[]): number[] {
    const sortF = (a:number,b:number):number => a-b;
    nums1.sort(sortF);
    nums2.sort(sortF);
    let i:number = 0;
    let j:number = 0;
    let rus:Array<number> = [] ;
    while(i<nums1.length && j<nums2.length){
        if(nums2[j] === nums1[i]){
            rus.push(nums2[j])
            i++;
            j++;
        }else if(nums1[i] < nums2[j]){
            i++;
        }else{
            j++;
        }
    }
    return rus;
};
```

#### åˆ©ç”¨å“ˆå¸Œæ˜ å°„

```ts
function intersect(nums1: number[], nums2: number[]): number[] {
    const bus = new Map();
  const numsMin = nums1.length > nums2.length ? nums2 : nums1,
    numsMax = numsMin === nums1 ? nums2 : nums1;
  let minL = 0 ,minR = numsMin.length - 1;
  while (minL <= minR) {
    if(bus.has(numsMin[minL])){
        let fre = bus.get(numsMin[minL]);
        bus.set(numsMin[minL],++fre)
    }else{
        bus.set(numsMin[minL], 1)
    }
    if(minL !== minR && bus.has(numsMin[minR])){
        let fre = bus.get(numsMin[minR]);
        bus.set(numsMin[minR],++fre)
    }else if(minL !== minR){
        bus.set(numsMin[minR], 1)
    }
        minL++;
        minR--;
  }
  
  let maxL = 0 ,maxR = numsMax.length;
  let rus = [];
  while(maxL <= maxR){
      if(bus.has(numsMax[maxL])){
          let fre = bus.get(numsMax[maxL])
          if(fre > 0){
              bus.set(numsMax[maxL],--fre);
              rus.push(numsMax[maxL]);
          }
      }
      if(bus.has(numsMax[maxR])){
          let fre = bus.get(numsMax[maxR])
          if(fre > 0){
              bus.set(numsMax[maxR],--fre);
              rus.push(numsMax[maxR]);
          }
      }
      maxL++;
      maxR--;
  }
  return rus;
};
```

å…¶ä»–äººçš„è§£æ³•ï¼š



> å¦‚æœ`nums 2`çš„å…ƒç´ å­˜å‚¨åœ¨ç£ç›˜ä¸Šï¼Œç£ç›˜å†…å­˜æ˜¯æœ‰é™çš„ï¼Œå¹¶ä¸”ä½ ä¸èƒ½ä¸€æ¬¡åŠ è½½æ‰€æœ‰çš„å…ƒç´ åˆ°å†…å­˜ä¸­ã€‚é‚£ä¹ˆå°±æ— æ³•é«˜æ•ˆåœ°å¯¹`nums 2`è¿›è¡Œæ’åºï¼Œå› æ­¤æ¨èä½¿ç”¨æ–¹æ³•ä¸€è€Œä¸æ˜¯æ–¹æ³•äºŒã€‚åœ¨æ–¹æ³•ä¸€ä¸­ï¼Œ`nums 2`åªå…³ç³»åˆ°æŸ¥è¯¢æ“ä½œï¼Œå› æ­¤æ¯æ¬¡è¯»å– `nums 2`ä¸­çš„ä¸€éƒ¨åˆ†æ•°æ®ï¼Œå¹¶è¿›è¡Œå¤„ç†å³å¯ã€‚
>
> æ¥è‡ªleetcode

#### å’Œå¯è¢« K æ•´é™¤çš„å­æ•°ç»„

ç»™å®šä¸€ä¸ªæ•´æ•°æ•°ç»„ nums å’Œä¸€ä¸ªæ•´æ•° k ï¼Œè¿”å›å…¶ä¸­å…ƒç´ ä¹‹å’Œå¯è¢« k æ•´é™¤çš„ï¼ˆè¿ç»­ã€éç©ºï¼‰ å­æ•°ç»„ çš„æ•°ç›®ã€‚

å­æ•°ç»„ æ˜¯æ•°ç»„çš„ è¿ç»­ éƒ¨åˆ†ã€‚

 

ç¤ºä¾‹ 1ï¼š

> è¾“å…¥ï¼š`nums = [4,5,0,-2,-3,1], k = 5`
> è¾“å‡ºï¼š7

**è§£é‡Šï¼š**
æœ‰ 7 ä¸ªå­æ•°ç»„æ»¡è¶³å…¶å…ƒç´ ä¹‹å’Œå¯è¢« k = 5 æ•´é™¤ï¼š
`[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]`

ç¤ºä¾‹ 2:

> è¾“å…¥:` nums = [5], k = 9`
> è¾“å‡º: 0

 

æç¤º:

    1 <= nums.length <= 3 * 104
    -104 <= nums[i] <= 104
    2 <= k <= 104

æˆ‘çš„æ€è·¯ï¼š

æœ€å…ˆè¯•äº†æš´åŠ›è§£æ³•ï¼Œè¶…è¿‡äº†æ—¶é—´é™åˆ¶ï¼Œç„¶åç”¨å“ˆå¸Œæ˜ å°„è§£å†³ï¼›

```ts
function intersect(nums: number[], k: number): number{
    const bus = new Map().set(0, 1);
    let value = 0, rus = 0;
    for (let item of nums) {
        value += item
        const mode = (value % k + k) % k
        if (bus.has(mode)) {
            let con = bus.get(mode)
            bus.set(mode, ++con);
        } else {
            bus.set(mode, 1);
        }

    }
    bus.forEach((v, k) => {
        rus += v * (v - 1) / 2;
    })
    return rus
};
intersect([4,5,0,-2,-3,1],5)
```



æ”¹è¿›ä¹‹åï¼š

```ts
function subarraysDivByK(nums: number[], k: number): number {
    const bus = new Map().set(0,1);
    let value = 0,rus = 0;
    for(let item of nums){
        value += item
        const mode = (value % k + k) % k;
        let count = bus.get(mode) || 0;
        
        rus += count;
        bus.set(mode,++count)
    }
    return rus
};
```

